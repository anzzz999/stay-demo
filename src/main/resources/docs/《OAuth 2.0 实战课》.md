## 《OAuth 2.0 实战课》



**OAuth 2.0 是什么？**

OAuth 2.0 一词中的 “Auth” 表示 “授权”，字母 “O” 是 Open 的简称，表示 “开放” ，连在一起就表示 “开放授权”。



课程目录

<img src="https://static001.geekbang.org/resource/image/96/08/969e0e39d327d109ab23e794a4263708.jpg?wh=1920*1451" alt="img" style="zoom:67%;" />



### 01 | OAuth 2.0是要通过什么方式解决什么问题？

OAuth 2.0 是什么？用一句话总结来说，**OAuth 2.0 就是一种授权协议。**OAuth 2.0 这种授权协议，就是**保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据。**因此，我们常常还会听到一种说法，OAuth 2.0 是一种安全协议。

**OAuth 2.0 授权的核心就是颁发访问令牌、使用访问令牌。**

总结来说，我需要你记住以下这 3 个关键点：

1. OAuth 2.0 的核心是授权许可，更进一步说就是令牌机制。也就是说，像小兔软件这样的第三方软件只有拿到了京东商家开放平台颁发的问令牌，也就是得到了**授权**许可，然后才可以代表用户访问他们的数据。
2. 互联网中所有的受保护资源，几乎都是以 Web API 的形式来提供访问的，比如极客时间 App 要获取用户的头像、昵称，小兔软件要获取用户的店铺订单，我们说 OAuth 2.0 与安全相关，是用来保护 Web API 的。另外，第三方软件通过 OAuth 2.0 取得访问权限之后，用户便把这些权限**委托**给了第三方软件，我们说 OAuth 2.0 是一种委托协议，也没问题。
3. 也正因为像小兔这样的第三方软件，每次都是用访问令牌而不是用户名和密码来请求用户的数据，才大大**减少了安全风险**上的“攻击面”。不然，我们试想一下，每次都带着用户名和密码来访问数量众多的 Web API ，是不是增加了这个“攻击面”。因此，我们说 OAuth 2.0 的核心，就是颁发访问令牌和使用访问令牌。



<img src="https://static001.geekbang.org/resource/image/77/79/77197844a8f41a33cb68947b1dc9ee79.png?wh=1564*1118" alt="img" style="zoom:33%;" />

Q:为什么要用授权码换取token，而不是直接获取token？

A:一般**code是给客户端的，比如通过web跳转传回来，这个时候code就是暴露的**。当然也有类似JS直接获取的，同样也是暴露的。所以**code是不安全的，有效时间也会很短**。**而code换取的token往往是服务端之间的通讯，是保密且比较长时间有效的**。 另一方面，token是用户与授权方交互才能直接给出的，如果第三方要直接获取token，说明用户跟授权方的交互要委托给第三方。比如你的用户名密码要给到第三方，第三方再跟授权方换取token，这里就向第三方暴露了用户的机密。



### 02 | 授权码许可类型中，为什么一定要有授权码？

#### 为什么需要授权码？

**在 OAuth 2.0 的体系里面有 4 种角色，按照官方的称呼它们分别是资源拥有者、客户端、授权服务和受保护资源。**不过，这里的客户端，我更愿意称其为第三方软件，而且在咱们这个课程中，都是以第三方软件在举例子。所以，在后续的讲解中我统一把它称为第三方软件。所以，你在看官方资料的时候，可以自己对应下。为了便于你理解，我还是拿小兔软件来举例子，将官方的称呼 “照进现实”，对应关系就是，**资源拥有者 -> 小明，第三方软件 -> 小兔软件，授权服务 -> 京东商家开放平台的授权服务，受保护资源 -> 小明店铺在京东上面的订单**。

**OAuth 诞生之初就是为了解决 Web 浏览器场景下的授权问题**，所以我基于浏览器的场景，在上一讲的小明使用小兔软件打印订单的整体流程的基础上，画了一个授权码许可类型的序列图。

<img src="https://static001.geekbang.org/resource/image/96/32/96973a6f5637fb3d1049f6d456702932.png?wh=1814*1370" alt="img" style="zoom: 50%;" />

没有授权码的思路继续想，**如果这里直接返回访问令牌，那我们肯定不能使用重定向的方式。因为这样会把安全保密性要求极高的访问令牌暴露在浏览器上，从而将会面临访问令牌失窃的安全风险。显然，这是不能被允许的。**

前端服务拿到授权和后端服务拿到授权的安全性级别是不一样的，后端比较安全，前端服务存在浏览器暴露的风险。 上面讲的，完整的授权流程，会把 code 返回给前端服务，token 返回给后端业务。 **而授权流程，若直接把 token 返回给后端服务会导致前端页面不跳转，若直接把 token 给前端服务存在 token 被窃取的风险。**



#### 授权码许可类型的通信过程

**间接通信**

<img src="https://static001.geekbang.org/resource/image/9e/bf/9e4f51f1f77840bd0b8f756be40d42bf.jpg?wh=1920*1036" alt="img" style="zoom:33%;" />

不知道你注意到没有，第三方软件小兔和授权服务之间，并没有发生直接的通信，而是**通过浏览器这个“中间人” 来 “搭线”的**。因此，我们说这是一个间接通信的方式。

**直接通信**

<img src="https://static001.geekbang.org/resource/image/84/9b/84dc2d6f578b6968b782a0280a73be9b.png?wh=1348*692" alt="img" style="zoom:33%;" />

第三方软件小兔获取到授权码 code 值后，向授权服务发起获取访问令牌 access_token 的通信请求。这个请求是第三方软件服务器跟授权服务的服务器之间的通信，都是在后端服务器之间的请求和响应，因此也叫作后端通信。



#### 两个 “一伙”

不知道你有没有意识到，OAuth 2.0 中的 4 个角色是 “两两站队” 的：资源拥有者和第三方软件“站在一起”，因为第三方软件要代表资源拥有者去访问受保护资源；授权服务和受保护资源“站在一起”，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。

<img src="https://static001.geekbang.org/resource/image/1c/ff/1c86e21496882894d7f03b35a01972ff.jpg?wh=1920*612" alt="img" style="zoom:33%;" />



#### 一定要有浏览器吗？

OAuth 2.0 发展之初，开放生态环境相对单薄，以浏览器为代理的 Web 应用居多，授权码许可类型 “理所当然” 地被应用到了通过浏览器才能访问的 Web 应用中。但实际上，OAuth 2.0 是一个授权理念，或者说是一种授权思维。它的授权码模式的思维可以移植到很多场景中，比如微信小程序。**在开发微信小程序应用时，我们通过授权码模式获取用户登录信息，官方文档的地址示例中给出的 grant_type=authorization_code ，就没有用到浏览器。**



Q:授权码被盗取后，人家不能也模拟服务器请求获取access_token吗？

A:一方面授权码也都有有效期，另外一方面除非再盗取了第三方应用软件的app_id、secret才能成功请求资源。还要设置服务器IP白名单、而且一般的来说code只能用一次。





### 03 | 授权服务：授权码和访问令牌的颁发流程是怎样的？



做第三方社交登录，比如 微信登录、gitee登录、微博登录，**第一件事情都是要去相应开平台注册我们的应用。**要去平台那里“**备案**”，也就是注册。注册完后，开放平台就会给小兔软件 app_id 和 app_secret 等信息，以方便后面授权时的各种身份校验。

授权服务就是负责颁发访问令牌的服务。更进一步地讲，OAuth 2.0 的核心是授权服务，而授权服务的核心就是令牌。

那么，授权服务到底是怎么生成访问令牌的，这其中包含了哪些操作呢？还有一个问题是，访问令牌过期了而用户又不在场的情况下，又如何重新生成访问令牌呢？



#### 授权服务的工作过程

在授权码许可类型中，授权服务的工作，可以划分为两大部分，一个是**颁发授权码 code**，一个是**颁发访问令牌 access_token**。为了更能表达授权码和访问令牌的存在，我在图中用深色将其标注了出来：

<img src="https://static001.geekbang.org/resource/image/a5/11/a5d231c5b356ecf2031yy7d17207c011.png?wh=2086*800" alt="img" style="zoom:67%;" />



#### 过程一：颁发授权码 

code在这个过程中，授权服务需要完成两部分工作，分别是**准备工作**和**生成授权码 code**。

**第一步，验证基本信息。**

**验证基本信息，包括对第三方软件小兔合法性和回调地址合法性的校验。**在 Web 浏览器环境下，颁发 code 的整个请求过程，都是浏览器通过前端通信来完成，这就意味着所有信息都有被冒充的风险。因此，授权服务必须对第三方软件的存在性做判断。同样，回调地址也是可以被伪造的。比如，不法分子将其伪装成钓鱼页面，或者是带有恶意攻击性的软件下载页面。因此从安全上考虑，授权服务需要对回调地址做基本的校验。

在授权服务的程序中，这两步验证通过后，就会生成或者响应一个页面（**属于授权服务器上的页面**），以提示小明进行授权。

**第二步，验证权限范围（第一次）。**

既然是授权，就会涉及范围。比如，我们使用微信登录第三方软件的时候，会看到微信提示我们，第三方软件可以获得你的昵称、头像、性别、地理位置等。**如果你不想让第三方软件获取你的某个信息，那么可以不选择这一项。**同样在小兔中也是一样，当小明为小兔进行授权的时候，也可以选择给小兔的权限范围，比如是否授予小兔获取 3 个月以前的订单的访问权限。这就意味着，我们需要对小兔传过来的 scope 参数，与小兔注册时申请的权限范围做比对。**如果请求过来的权限范围大于注册时的范围，就需要作出越权提示**。**记住，此刻是第一次权限校验。**

**第三步，生成授权请求页面**

这个授权请求页面就是授权服务上的页面，如下图所示：

<img src="https://static001.geekbang.org/resource/image/5e/66/5e024b40a98b65a54082106a96734c66.png?wh=724*318" alt="img" style="zoom:67%;" />

小明可以选择缩小这个权限范围，比如仅授予获取 today 信息的权限。至此，颁发授权码 code 的准备工作就完成了。你要注意哈，我一直强调说这也是准备工作，因为当用户点击授权按钮“approve”后，才会生成授权码 code 值和访问令牌 acces_token 值，“一切才真正开始”。

**第四步，验证权限范围（第二次）。**

在步骤二中，生成授权页面之前授权服务进行的第一次校验，是对比小兔请求过来的权限范围 scope 和注册时的权限做的比对。这里的第二次验证权限范围，是用小明进行授权之后的权限，再次与小兔软件注册的权限做校验。

小明选择了一定的权限范围给到授权服务，对于权限的校验我们要重视对待，凡是输入性数据都会涉及到合法性检查。另外，这也是要求我们养成一种**在服务端对输入数据的请求，都尽可能做一次合法性校验的好习惯**。

**第五步，处理授权请求，生成授权码 code。**

当小明同意授权之后，授权服务会校验响应类型 response_type 的值。response_type 有 code 和 token 两种类型的值。在这里，我们是用授权码流程来举例的，因此代码要验证 response_type 的值是否为 code。

**在授权服务中，需要将生成的授权码 code 值与 app_id、user 进行关系映射。也就是说，一个授权码 code，表示某一个用户给某一个第三方软件进行授权**，比如小明给小兔软件进行的授权。同时，**我们需要将 code 值和这种映射关系保存起来，以便在生成访问令牌 access_token 时使用。**

在生成了授权码 code 之后，我们也按照上面所述绑定了响应的映射关系。这时，你还记得我之前讲到的授权码是临时的、一次性凭证吗？因此，我们还需要为 code 设置一个有效期。**OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且一个授权码 code 只能被使用一次。**不过根据经验呢，在生产环境中 code 的有效期一般不会超过 5 分钟。

同时，**授权服务还需要将生成的授权码 code 跟已经授权的权限范围 rscope 进行绑定并存储**，以便后续颁发访问令牌时，我们能够通过 code 值取出授权范围并与访问令牌绑定。因为第三方软件最终是通过访问令牌来请求受保护资源的。

**第六步，重定向至第三方软件。**

生成授权码 code 值之后，授权服务需要将该 code 值告知第三方软件小兔。开始时我们提到，颁发授权码 code 是通过前端通信完成的，因此这里采用重定向的方式。这一步的重定向，也是我在上一讲中提到的第二次重定向。



#### 过程二：颁发访问令牌 access_token

拿着授权码 code 来请求的时候，授权服务需要为之生成最终的请求访问令牌。这个过程主要包括验证第三方软件小兔是否存在、验证 code 值是否合法和生成 access_token 值这三大步。

**第一步，验证第三方软件是否存在。**

此时，接收到的 grant_type 的类型为 authorization_code。由于颁发访问令牌是通过后端通信完成的，所以这里除了要校验 app_id 外，还要校验 app_secret。

**第二步，验证授权码 code 值是否合法。**

授权服务在颁发授权码 code 的阶段已经将 code 值存储了起来，此时对比从 request 中接收到的 code 值和从存储中取出来的 code 值。在我们给出的课程相关代码中，code 值对应的 key 是 app_id 和 user 的组合值。

这里我们一定要记住，**确认过授权码 code 值有效以后，应该立刻从存储中删除当前的 code 值**，以防止第三方软件恶意使用一个失窃的授权码 code 值来请求授权服务。

**第三步，生成访问令牌 access_token 值。**

关于按照什么规则来生成访问令牌 access_token 的值，OAuth 2.0 规范中并没有明确规定，但必须符合三个原则：**唯一性、不连续性、不可猜性。**

和授权码 code 值一样，我们需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。也就是说，一个访问令牌 access_token 表示某一个用户给某一个第三方软件进行授权。同时，授权服务还需要将授权范围跟访问令牌 access_token 做绑定。最后，还需要为该访问令牌设置一个过期时间 expires_in，比如 1 天。



#### 刷新令牌

在生成访问令牌的时候，我们还给它附加了一个过期时间 expires_in，这意味着访问令牌会在一定的时间后失效。访问令牌失效，就意味着资源拥有者给第三方软件的授权失效了，第三方软件无法继续访问资源拥有者的受保护资源了。

为此，**OAuth 2.0 中引入了刷新令牌的概念，也就是刷新访问令牌 access_token 的值。这就意味着，有了刷新令牌，用户在一定期限内无需重新点击授权按钮，就可以继续使用第三方软件**。

刷新令牌也是给第三方软件使用的，同样需要遵循**先颁发再使用**的原则。因此，我们还是从颁发和使用两个环节来学习刷新令牌。不过，这个颁发和使用流程和访问令牌有些是相同的，所以我只会和你重点讲述其中的区别。

**颁发刷新令牌**

其实，颁发刷新令牌和颁发访问令牌是一起实现的，都是在过程二的步骤三**生成访问令牌 access_token 中生成的。也就是说，第三方软件得到一个访问令牌的同时，也会得到一个刷新令牌。**

为什么要一起生成访问令牌和刷新令牌呢？其实，这就回到了刷新令牌的作用上了。**刷新令牌存在的初衷是，在访问令牌失效的情况下，为了不让用户频繁手动授权，用来通过系统重新请求生成一个新的访问令牌。那么，如果访问令牌失效了，而“身边”又没有一个刷新令牌可用，岂不是又要麻烦用户进行手动授权了。所以，它必须得和访问令牌一起生成。**到这里，我们就解决了刷新令牌的颁发问题。

**使用刷新令牌**

说到刷新令牌的使用，我们需要先明白一点。在 OAuth 2.0 规范中，**刷新令牌是一种特殊的授权许可类型，是嵌入在授权码许可类型下的一种特殊许可类型。在授权服务的代码里，当我们接收到这种授权许可请求的时候，会先比较 grant_type 和 refresh_token 的值，然后做下一步处理。**

**第一步，接收刷新令牌请求，验证基本信息。**

此时请求中的 grant_type 值为 refresh_token。和颁发访问令牌前的验证流程一样，这里我们也需要验证第三方软件是否存在。需要注意的是，这里需要同时验证刷新令牌是否存在，目的就是要保证传过来的刷新令牌的合法性。另外，我们还需要验证刷新令牌是否属于该第三方软件。授权服务是将颁发的刷新令牌与第三方软件、当时的授权用户绑定在一起的，因此这里需要判断该刷新令牌的归属合法性。

需要注意，**一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌。**

**第二步，重新生成访问令牌。**

生成访问令牌的处理流程，与颁发访问令牌环节的生成流程是一致的。授权服务会将新的访问令牌和新的刷新令牌，一起返回给第三方软件。

#### 总结

总结来讲，关于这一讲，我希望你能记住以下 3 点。

1. 授权服务的核心就是，**先颁发授权码 code 值，再颁发访问令牌 access_token 值。**
2. 在颁发访问令牌的同时**还会颁发刷新令牌 refresh_token 值**，这种机制可以在无须用户参与的情况下用于生成新的访问令牌。正如我们讲到的小明使用小兔软件的例子，当访问令牌过期的时候，刷新令牌的存在可以大大提高小明使用小兔软件的体验。
3. **授权还要有授权范围**，不能让第三方软件获得比注册时权限范围还大的授权，也不能获得超出了用户授权的权限范围，始终确保最小权限安全原则。比如，小明只为小兔软件授予了获取当天订单的权限，那么小兔软件就不能访问小明店铺里面的历史订单数据。思考题