## 设计模式

1.使用策略模式 + 工厂模式 消灭 if else

 [业务复杂=if else？刚来的大神竟然用策略+工厂彻底干掉了他们！](https://juejin.cn/post/6844903974525468680#comment )



### 单例模式

（确保一个类只有一个实例，并向整个系统提供这个实例）

单例模式应该是23种设计模式中最简单的一种模式了，下面我们从单例模式的定义、类型、结构和使用要素四个方面来介绍它。

1、单例模式理论基础

**定义：** **确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。**

**类型：** **创建型模式**

**结构：**

　　　　　　　　　　　　　　　　　　　　　　![单例模式类图.gif-9.2kB](https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzLzhjbGoweDJnM2E3NDJlZXJlYzJ3OTE2di8lRTUlOEQlOTUlRTQlQkUlOEIlRTYlQTglQTElRTUlQkMlOEYlRTclQjElQkIlRTUlOUIlQkUuZ2lm)

　　特别地，为了更好地理解上面的类图，我们以此为契机，介绍一下类图的几个知识点：

- 类图分为三部分，依次是类名、属性、方法；
- 以<<开头和以>>结尾的为注释信息；
- 修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见；
- 带下划线的属性或方法代表是静态的。

**三要素：**

- **私有的构造方法；**
- **指向自己实例的私有静态引用；**
- **以自己实例为返回值的静态的公有方法。**

2、单线程环境下的两种经典实现

　　在介绍单线程环境中单例模式的两种经典实现之前，我们有必要先解释一下 **立即加载** 和**延迟加载** 两个概念。

- **立即加载 ：** 在类加载初始化的时候就主动创建实例；

- **延迟加载 ：** 等到真正使用的时候才去创建实例，不用时不去主动创建。

  　　在单线程环境下，单例模式根据实例化对象时机的不同，有两种经典的实现：一种是 **饿汉式单例(立即加载)**，一种是 **懒汉式单例(延迟加载)**。**饿汉式单例在单例类被加载时候，就实例化一个对象并交给自己的引用；而懒汉式单例只有在真正使用的时候才会实例化一个对象并交给自己的引用。**代码示例分别如下：

**饿汉式单例：**

```java
// 饿汉式单例
public class Singleton1 {
 
    // 指向自己实例的私有静态引用，主动创建
    private static Singleton1 singleton1 = new Singleton1();
 
    // 私有的构造方法
    private Singleton1(){}
 
    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton1 getSingleton1(){
        return singleton1;
    }
}
```

- 我们知道，**类加载的方式是按需加载，且加载一次。**因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。



**懒汉式单例：**

```java

// 线程安全的懒汉式单例
public class Singleton3 {
 
    //使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作，可能创建一个不完整的实例
    private static volatile Singleton3 singleton3;
 
    private Singleton3() {
    }
 
    public static Singleton3 getSingleton3() {
        // Double-Check idiom
        if (singleton3 == null) {
            synchronized (Singleton3.class) {       // 1
                // 只需在第一次创建实例时才同步
                if (singleton3 == null) {       	// 2
                    singleton3 = new Singleton3();  // 3
                }
            }
        }
        return singleton3;
    }
}
```

如上述代码所示，为了在保证单例的前提下提高运行效率，我们需要对 singleton3 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。这种做法无疑是优秀的，但是我们必须注意一点：
　　 
　　**必须使用volatile关键字修饰单例引用。**

　**那么，如果上述的实现没有使用 volatile 修饰 singleton3，会导致什么情形发生呢？** 为解释该问题，我们分两步来阐述：

**(1)、当我们写了 new 操作，JVM 到底会发生什么？**

　　首先，我们要明白的是： **new Singleton3() 是一个非原子操作。**代码行singleton3 = new Singleton3(); 的执行过程可以形象地用如下3行伪代码来表示：

```java
memory = allocate();        //1:分配对象的内存空间

ctorInstance(memory);       //2:初始化对象

singleton3 = memory;        //3:使singleton3指向刚分配的内存地址
```

-  

　　**但实际上，这个过程可能发生无序写入(指令重排序)，也就是说上面的3行指令可能会被重排序导致先执行第3行后执行第2行，**也就是说其真实执行顺序可能是下面这种：

```java
memory = allocate();        //1:分配对象的内存空间

singleton3 = memory;        //3:使singleton3指向刚分配的内存地址

ctorInstance(memory);       //2:初始化对象
```

　　这段伪代码演示的情况不仅是可能的，而且是一些 JIT 编译器上真实发生的现象。

如果线程A执行完1和3，instance对象还未完成初始化，但是已经不再指向null。此时线程B抢占到CPU资源，执行第一次的检测结果为false，则执行返回，从而返回一个还未初始化完成的instance对象，从而出导致问题出现。要解决这个问题，只需要使用volatile关键字修饰instance对象即可。


### 工厂模式

（定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类）

工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种**创建型**模式。

**意图**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决**：主要解决接口选择的问题。

#### 1. 简单工厂模式

#### 2. 工厂方法模式(Factory Method)

#### 3. 抽象工厂模式(Abstract Factory)



### 观察者模式

（一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新）

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。**观察者模式（Observer）**，又叫**发布-订阅模式（Publish/Subscribe）**，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

**意图**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决**：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

#### 应用实例

- 通知老师/老板来了
- 拍卖，拍卖师观察最高标价，然后通知给其它竞价者竞价



### 装饰者模式

（在不改变原有类结构的基础上，为现有的对象添加新的功能）

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于**结构型**模式，它是作为现有的类的一个包装。

**意图**：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决**：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。



### 门面模式

##### （客户端和这个门面直接交互，由门面去调用子系统的模块）

slf4j是门面模式的典型应用，因此在讲slf4j前，我们先简单回顾一下门面模式，

门面模式，其核心为**外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用**。用一张图来表示门面模式的结构为：

![img](https://images2018.cnblogs.com/blog/801753/201803/801753-20180321204740208-1670144043.png)

门面模式的核心为Facade即门面对象，门面对象核心为几个点：

- 知道所有子角色的功能和责任
- 将客户端发来的请求委派到子系统中，没有实际业务逻辑
- 不参与子系统内业务逻辑的实现