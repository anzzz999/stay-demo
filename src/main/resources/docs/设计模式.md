## 设计模式

1.使用策略模式 + 工厂模式 消灭 if else

 [业务复杂=if else？刚来的大神竟然用策略+工厂彻底干掉了他们！](https://juejin.cn/post/6844903974525468680#comment )



### 单例模式

（确保一个类只有一个实例，并向整个系统提供这个实例）

单例模式应该是23种设计模式中最简单的一种模式了，下面我们从单例模式的定义、类型、结构和使用要素四个方面来介绍它。

1、单例模式理论基础

**定义：** **确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。**

**类型：** **创建型模式**

**结构：**

　　　　　　　　　　　　　　　　　　　　　　![单例模式类图.gif-9.2kB](https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzLzhjbGoweDJnM2E3NDJlZXJlYzJ3OTE2di8lRTUlOEQlOTUlRTQlQkUlOEIlRTYlQTglQTElRTUlQkMlOEYlRTclQjElQkIlRTUlOUIlQkUuZ2lm)

　　特别地，为了更好地理解上面的类图，我们以此为契机，介绍一下类图的几个知识点：

- 类图分为三部分，依次是类名、属性、方法；
- 以<<开头和以>>结尾的为注释信息；
- 修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见；
- 带下划线的属性或方法代表是静态的。

**三要素：**

- **私有的构造方法；**
- **指向自己实例的私有静态引用；**
- **以自己实例为返回值的静态的公有方法。**

2、单线程环境下的两种经典实现

　　在介绍单线程环境中单例模式的两种经典实现之前，我们有必要先解释一下 **立即加载** 和**延迟加载** 两个概念。

- **立即加载 ：** 在类加载初始化的时候就主动创建实例；

- **延迟加载 ：** 等到真正使用的时候才去创建实例，不用时不去主动创建。

  　　在单线程环境下，单例模式根据实例化对象时机的不同，有两种经典的实现：一种是 **饿汉式单例(立即加载)**，一种是 **懒汉式单例(延迟加载)**。**饿汉式单例在单例类被加载时候，就实例化一个对象并交给自己的引用；而懒汉式单例只有在真正使用的时候才会实例化一个对象并交给自己的引用。**代码示例分别如下：

**饿汉式单例：**

```java
// 饿汉式单例
public class Singleton1 {
 
    // 指向自己实例的私有静态引用，主动创建
    private static Singleton1 singleton1 = new Singleton1();
 
    // 私有的构造方法
    private Singleton1(){}
 
    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton1 getSingleton1(){
        return singleton1;
    }
}
```

- 我们知道，**类加载的方式是按需加载，且加载一次。**因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。



**懒汉式单例：**

```java

// 线程安全的懒汉式单例
public class Singleton3 {
 
    //使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作，可能创建一个不完整的实例
    private static volatile Singleton3 singleton3;
 
    private Singleton3() {
    }
 
    public static Singleton3 getSingleton3() {
        // Double-Check idiom
        if (singleton3 == null) {
            synchronized (Singleton3.class) {       // 1
                // 只需在第一次创建实例时才同步
                if (singleton3 == null) {       	// 2
                    singleton3 = new Singleton3();  // 3
                }
            }
        }
        return singleton3;
    }
}
```

如上述代码所示，为了在保证单例的前提下提高运行效率，我们需要对 singleton3 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。这种做法无疑是优秀的，但是我们必须注意一点：
　　 
　　**必须使用volatile关键字修饰单例引用。**

　**那么，如果上述的实现没有使用 volatile 修饰 singleton3，会导致什么情形发生呢？** 为解释该问题，我们分两步来阐述：

**(1)、当我们写了 new 操作，JVM 到底会发生什么？**

　　首先，我们要明白的是： **new Singleton3() 是一个非原子操作。**代码行singleton3 = new Singleton3(); 的执行过程可以形象地用如下3行伪代码来表示：

```java
memory = allocate();        //1:分配对象的内存空间

ctorInstance(memory);       //2:初始化对象

singleton3 = memory;        //3:使singleton3指向刚分配的内存地址
```

-  

　　**但实际上，这个过程可能发生无序写入(指令重排序)，也就是说上面的3行指令可能会被重排序导致先执行第3行后执行第2行，**也就是说其真实执行顺序可能是下面这种：

```java
memory = allocate();        //1:分配对象的内存空间

singleton3 = memory;        //3:使singleton3指向刚分配的内存地址

ctorInstance(memory);       //2:初始化对象
```

　　这段伪代码演示的情况不仅是可能的，而且是一些 JIT 编译器上真实发生的现象。

如果线程A执行完1和3，instance对象还未完成初始化，但是已经不再指向null。此时线程B抢占到CPU资源，执行第一次的检测结果为false，则执行返回，从而返回一个还未初始化完成的instance对象，从而出导致问题出现。要解决这个问题，只需要使用volatile关键字修饰instance对象即可。


### 工厂模式

（定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类）

工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种**创建型**模式。

**意图**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决**：主要解决接口选择的问题。

#### 1. 简单工厂模式

#### 2. 工厂方法模式(Factory Method)

#### 3. 抽象工厂模式(Abstract Factory)



### 观察者模式

（一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新）

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。**观察者模式（Observer）**，又叫**发布-订阅模式（Publish/Subscribe）**，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

**意图**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决**：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

#### 应用实例

- 通知老师/老板来了
- 拍卖，拍卖师观察最高标价，然后通知给其它竞价者竞价



### 装饰者模式

（在不改变原有类结构的基础上，为现有的对象添加新的功能）

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于**结构型**模式，它是作为现有的类的一个包装。

**意图**：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决**：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。



### 门面模式

##### （客户端和这个门面直接交互，由门面去调用子系统的模块）

slf4j是门面模式的典型应用，因此在讲slf4j前，我们先简单回顾一下门面模式，

门面模式，其核心为**外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用**。用一张图来表示门面模式的结构为：

![img](https://images2018.cnblogs.com/blog/801753/201803/801753-20180321204740208-1670144043.png)

门面模式的核心为Facade即门面对象，门面对象核心为几个点：

- 知道所有子角色的功能和责任
- 将客户端发来的请求委派到子系统中，没有实际业务逻辑
- 不参与子系统内业务逻辑的实现













## 设计模式之美

### 01 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识

### 原因

1 . 应对面试中的设计模式相关问题

2 . 告别被人吐槽的烂代码

3 . 提高复杂代码的设计和开发能力

4 . 让读源码、学框架事半功倍

5 . 为你的职场发展做铺垫



### 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

#### 1. 评价代码最常用标准

​		**可维护性**(maintainability)

 - 代码易维护：在不破坏原有代码设计、不引入新的bug的情况下，能够快速地修改或者添加代码。

 - 即bug容易修复，修改、添加功能能够轻松完成。

  

  	**可读性**(readability)

  - 是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否高内聚低耦合等等。

  

  	**可扩展性**(extensibility)

- 在不修改或者少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。

  

  **灵活性**(flexibility)

- 易用、易扩展、易复用

  

  **简洁性**(simplicity)

- KISS原则 ： Keep It Simple, Stupid.

  

  **可复用性**(reusability)

- DRY : Don‘t Repeat Yourself.

- 后文会详说。

  

  **可测试性**(testability)

- 很重要。

- 重构部分会详说。


#### 2 . 如何写出高质量的代码？

需要掌握一些更加细化、更加能落地的编程方法论，如：**面向对象设计思想、设计原则、设计模式、编码规范、重构技巧**等。



### 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

#### 课程总结



<img src="https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png" alt="img" style="zoom:80%;" />





#### 1 . 面向对象

1. 主流编程风格：面向过程、面向对象（最主流）、函数式编程

2. 这部分需要掌握的七个大的知识点：
	- 四大特性：封装、抽象、继承、多态
	
	- 面向对象与面向过程的区别和联系
	
	- 面向对象分析、面向对象设计、面向对象编程
	
	- 接口和抽象类的区别以及各自的应用场景
	
	- 基于接口而非实现编程的设计思想
	
	- 多用组合少用继承的设计思想
	
	- 面向过程的贫血模型和面向对象的充血模型
	
	  

#### 2 . 设计原则

1. 设计原则：抽象，定义描述比较模糊，不同的人会有不同的解读。

2. 对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。

3. 需要理解透彻并掌握：
   - SOLID 原则 -SRP 单一职责原则
   
   - SOLID 原则 -OCP 开闭原则
   
   - SOLID 原则 -LSP 里式替换原则
   
- SOLID 原则 -ISP 接口隔离原则

- SOLID 原则 -DIP 依赖倒置原则

- DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


#### 3 . 设计模式

1. 设计模式：**软件开发过程中总结出来的一套解决方案或者设计思路**。

2. 大部分设计模式要解决的都是代码的**可扩展性**问题。

3. 学习难点：了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

4. 对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。

5. 设计模式简单的分类：
    - **创建型**：
     1.常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。
     2.不常用的有：原型模式。

    - **结构型**：
     1. 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。
     2. 不常用的有：门面模式、组合模式、享元模式。

    - **行为型**
     1. 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
     2. 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。  

#### 4 . 编程规范

1. **编程规范主要解决的是代码的可读性问题**。
2. **更加具体、更加偏重代码细节**。
3. 相关书籍：如《重构》《代码大全》《代码整洁之道》等。
4. 专栏总结了20 条规范。如果你暂时没有时间去看那些经典的书籍，看这些就够了。
5. 本专栏重构分为大重构和小重构两种类型，而**小重构利用的知识基本上就是编码规范**。




#### 5 . 代码重构

1. 需要掌握以下几个知识点：
   - 重构的目的（why）、对象（what）、时机（when）、方法（how）；

   - 保证重构不出错的技术手段：单元测试和代码的可测试性；

   - 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。


####  五者之间的联系

**面向对象编程是很多设计原则、设计模式等编码实现的基础。**
**设计原则是是很多设计模式（策略、模板等）的指导原则。**
**设计模式是解决方案。**
**编程规范主要解决的是代码的可读性问题。**
**重构作为保持代码质量不下降的有效手段。**



留言：“面向对象是武器，设计模式是招式，设计原则是心法，以心法为基础，以武器运用招式应对复杂的编程问题”。







### 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？

#### 1.面向对象编程与面向对象编程语言

1. 面向对象编程: OOP， Object Oriented Programming。
	**面向对象编程是一种编程范式或编程风格**。它**以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。**
2. 面向对象编程语言: OOPL，Object Oriented Programming Language。
	面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
3. 一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。



#### 2. 如何判定某编程语言是否是面向对象编程语言？

```java
- 面向对象编程语言: 某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元.
```



#### 3.什么是面向对象分析和面向对象设计？

1. 面向对象分析: OOA，全称是 Object Oriented Analysis；
2. 面向对象设计: OOD，全称是 Object Oriented Design。
3. 面向对象？
	- **围绕着对象或类来做需求分析和设计的**。
	- 分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。
4. **面向对象分析就是要搞清楚 做什么，**
5. **面向对象设计就是要搞清楚 怎么做，**
6. **面向对象编程就是将分析和设计的的结果 翻译成代码的过程**。



### 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

#### 封装（Encapsulation）: 如何隐藏信息、保护数据

**类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。**
**封装通过 访问权限控制 机制来支持的，即private、public等关键字控制。**
意义：
1.**增加可维护性**：防止因不了解业务逻辑而进行一些重要数据的修改。
2.**提高类的易用性**：如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。



#### 抽象（Abstraction）: 隐藏方法的具体实现

实现抽象特性：接口类、抽象类
**意义：**
**1.过滤一些非关键性的细节**
**2.抽象是一个非常宽泛的设计思想，在代码设计中气到非常重要的指导作用。**

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。



#### **继承（Inheritance）**

继承用来表示类之间的 is-a 关系，如猫是哺乳动物。
分为单继承或者是多继承，单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。
不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl 等。
**意义：代码复用**



#### 多态（Polymorphism）

多态：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

实现方法：

继承加方法重写
利用接口类语法
利用 duck-typing 语法（只要两个类具有相同的方法，就可以实现多态）

**意义：多态特性能提高代码的可扩展性和复用性。**


继承、重写、上转型



### 06| 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？

#### 什么是面向过程编程与面向过程编程语言？

面向过程编程：它以**过程**（方法、函数、操作）作为组织代码的基本单元，以数据与方法相分离为最主要的特点。
面向过程编程语言：最大特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
面向过程 or 面向对象的最基本区别：代码的组织方式不同。
面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。
面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中



#### 面向对象编程相比面向过程编程有哪些优势？

1. **OOP 更加能够应对大规模复杂程序的开发**

当我们开发代码量较大的系统时，类能很好的的组织函数和数据结构。
2. **OOP 风格的代码更易复用、易扩展、易维护**

**封装**特性，**通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据**，而不会像面向过程编程那样，数据可以被任意方法随意修改。**更有利于提高代码的易维护性**。
**抽象**特性，**基于接口的抽象（面向过程不具备），可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。**
**继承**特性，**子类重用父类代码，提高了代码的复用性。**
**多态**特性，**调用子类新的功能逻辑，而不是在原有代码上做修改，提高代码的扩展性。不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。**

3. **OOP 语言更加人性化、更加高级、更加智能**

我们在用二进制指令、汇编语言、面向过程编程语言的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。



### 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

今天你要掌握的重点内容是三种违反面向对象编程风格的典型代码设计。

**1. 滥用 getter、setter 方法**
在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

**2. Constants 类、Utils 类的设计问题**
对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

**3. 基于贫血模型的开发模式**
关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。



### 08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？

#### **1. 抽象类和接口的语法特性**

**抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法**。**接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法**。

#### **2. 抽象类和接口存在的意义**

抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了**解决代码复用问题**。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，**提高代码的扩展性**。

#### **3. 抽象类和接口的应用场景区别**

什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。



### 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

1. “基于接口而非实现编程”，这条原则的另一个表述方式，是“**基于抽象而非实现编程**”。后者的表述方式其实更能体现这条原则的设计初衷**。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性**。
2. 我们**在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中**。
3. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。



### 10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。

#### **1. 为什么不推荐使用继承？**

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但**继承层次过深、过复杂，也会影响到代码的可维护性**。在这种情况下，我们应该尽量少用，甚至不用继承。

#### **2. 组合相比继承有哪些优势？**

**继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用**。而这三个作用都可以通过**组合、接口、委托**三个技术手段来达成。除此之外，**利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题**。

#### **3. 如何判断该用组合还是继承？**

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。**如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承**。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。



### 11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？

**什么是DDD领域驱动设计？**

实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。

在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。



**总结**

我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。

不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，**对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势**。



###  12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，**主要区别在Service 层**。**在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。**

在基于充血模型的 DDD 开发模式下，**Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作**。

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和Repository 层的代码基本上相同。这是因为，**Repository 层的 Entity 生命周期有限**，**Controller 层的 VO 只是单纯作为一种 DTO**。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。**所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的**。



### 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。



### 14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？

面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。

**1. 划分职责进而识别出有哪些类**
根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

**2. 定义类及其属性和方法**
我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

**3. 定义类与类之间的交互关系**
UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

**4. 将类组装起来并提供执行入口**
我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。



###  15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？

**1. 如何理解单一职责原则（SRP）？**
**一个类只负责完成一个职责或者功能**。不要设计大而全的类，要设计粒度小、功能单一的类。**单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。**

**2. 如何判断类的职责是否足够单一？**
不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：

- 类中的代码行数、函数或者属性过多；
- 类依赖的其他类过多，或者依赖类的其他类过多；
- 私有方法过多；
- 比较难给类起一个合适的名字；
- 类中大量的方法都是集中操作类中的某几个属性。

**3. 类的职责是否设计得越单一越好？**
单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。**但是，如果拆分得过细，实际上会适得其反反倒会降低内聚性，也会影响代码的可维护性。**





### 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

**1. 如何理解“对扩展开放、对修改关闭”？**

**添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。**关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。

**2. 如何做到“对扩展开放、修改关闭”？**

我们要**时刻具备扩展意识、抽象意识、封装意识**。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

**3.为什么要“对扩展开放、对修改关闭”？**

**对拓展开放是为了应对变化（需求），对修改关闭是为了保证原有系统代码的稳定性，最终目的是为了让系统更有弹性。**



### 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，**按照协议来设计**”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，**多态和里式替换有点类似**，但它们关注的角度是不一样的。**多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路**。而**里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性**。



### 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

**1. 如何理解“接口隔离原则”？**

理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。

如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。

如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。

如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**2. 接口隔离原则与单一职责原则的区别**

**单一职责原则针对的是模块、类、接口的设计**。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。**接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一**。





### 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

**1. 控制反转**
实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

**2. 依赖注入**
依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

**3. 依赖注入框架**
我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

**4. 依赖反转原则**
依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。



**“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？**
区别是**“基于接口而非实现编程”强调的是“接口”，强调依赖的对象是接口，而不是具体的实现类;而“依赖注入”不强调这个，类或接口都可以，只要是从外部传入不是在内部new出来都可以称为依赖注入**。
1**依赖注入是一种具体编程技巧**，关注的是对象创建和类之间关系，目的提高了代码的扩展性，我们可以灵活地替换依赖的类。
2.**基于接口而非实现编程是一种设计原则**，关注抽象和实现，上下游调用稳定性，目的是降低耦合性，提高扩展性。
联系:都是基于开闭原则思路，**提高代码扩展性**!



### 20 | 理论六：为何说KISS、YAGNI原则看似简单，却经常被用错？

- KISS		Keep It Simple and Stupid.		尽量保持简单。
- YAGNI    You Ain’t Gonna Need It.           你不会需要它(不要做过度设计)

**KISS 原则是保持代码可读和可维护的重要手段**。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，**本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则**。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。

对于如何写出满足 KISS 原则的代码，我还总结了下面几条指导原则：

- 不要使用同事可能不懂的技术来实现代码；
- 不要重复造轮子，要善于使用已经有的工具类库；
- 不要过度优化。



### 21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？

**1.DRY 原则**

我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。**实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则**。实现逻辑不重复，但**功能语义重复的代码，也算是违反 DRY 原则**。除此之外，**代码执行重复也算是违反 DRY 原则**。

**2. 代码复用性**

今天，我们讲到提高代码**可复用性**的一些方法，有以下 7 点。

- **减少代码耦合**
- **满足单一职责原则**
- **模块化**
- **业务与非业务逻辑分离**
- **通用代码下沉**
- **继承、多态、抽象、封装**
- **应用模板等设计模式**

实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

**相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。**



### 22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？

**1. 如何理解“高内聚、松耦合”？**

**“高内聚、松耦合”**是一个非常重要的设计思想，能够**有效提高代码的可读性和可维护性**，缩小功能改动导致的代码改动范围。**“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。**

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

**2. 如何理解“迪米特法则”？**

**不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。**迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。



“高内聚、松耦合” “单一职责原则” “接口隔离原则” “基于接口而非实现编程” “迪米特法则”，你能总结一下它们之间的区别和联系吗？

**目的都是实现高内聚低耦合**，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。





### 23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？

技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。

面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。



### 24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？

**1. 为什么要分 MVC 三层开发？**

对于这个问题，我总结了以下 5 点原因。

- 分层能起到代码复用的作用
- 分层能起到隔离变化的作用
- 分层能起到隔离关注点的作用
- 分层能提高代码的可测试性
- 分层能应对系统的复杂性

**2.BO、VO、Entity 存在的意义是什么？**

从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们可以通过继承或者组合来解决。

如何进行数据对象之间的转化？最简单的方式就是手动复制。当然，你也可以使用 Java 中提供了数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。

尽管 VO、BO、Entity 的设计违背 OOP 的封装特性，有被随意修改的风险。但 Entity 和VO 的生命周期是有限的，都仅限在本层范围内，相对来说是安全的。Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。

**3. 总结用到的设计原则和思想**

从表面上看，做业务开发可能并不是特别有技术挑战，但是实际上，如果你要做到知其然知其所以然，做到透彻理解、真的懂，并不是件容易的事情。深挖一下，你会发现这其中还是蕴含了很多设计原则、思想和模式的。









### 33-33 | 理论五：让你最快速地改善代码质量的20条编程规范

**1. 关于命名**

- 命名的关键是能**准确达意**。对于不同作用域的命名，我们可以适当地选择不同的长度。
- 我们可以**借助类的信息来简化属性、函数的命名**，利用函数的信息来简化函数参数的命名。
- 命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用些反直觉的命名。
- 接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。

**2. 关于注释**

- 注释的内容主要包含这样三个方面：**做什么、为什么、怎么做**。对于一些复杂的类和接口，我们可能还需要写明“如何用”。
- **类和函数一定要写注释**，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。

**3. 关于代码风格**

- 函数、类多大才合适？函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。
- 一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。
- 善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，**可以使用空行来分割各个代码块**。
- 四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。
- 大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。
- 类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。

**4. 关于编码技巧**

- 将复杂的逻辑提炼拆分成函数和类。
- 通过**拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况**。
- 函数中**不要使用参数来做代码执行逻辑的控制**。
- 函数设计要职责单一。
- 移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。
- **用字面常量取代魔法数**。
- 用**解释性变量来解释复杂表达式**，以此提高代码可读性。

**5. 统一编码规范**

除了这三节讲到的比较细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。





### 34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200506094526185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FoYV9qYXNwZXI=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200506094554587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FoYV9qYXNwZXI=,size_16,color_FFFFFF,t_70)



### 35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”

实际上，通过这节课，我更想传达给你的是下面这样几个开发思想，我觉得这比我给你讲解具体的知识点更加有意义。

1. 即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。**我们要对代码质量有所追求**，不能只是凑活能用就好。花点心思写一段高质量的代码，比写 100 段凑活能用的代码，对你的代码能力提高更有帮助。
2. **知其然知其所以然**，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。
3. 设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。
4. 我经常讲，高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，**要想提高代码质量，还是要在细节处下功夫**。



### 36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？

对于函数出错返回数据类型，我总结了 4 种情况，它们分别是：错误码、NULL 值、空对象、异常对象。

**1. 返回错误码**

C 语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而 Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。

**2. 返回 NULL 值**

在多数编程语言中，我们用 NULL 来表示“不存在”这种语义**。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的 NULL 值比返回异常更加合理**。

**3. 返回空对象**

返回 NULL 值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。**当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况**。这样，我们在使用函数的时候，就可以不用做 NULL值判断。

对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如 Java 中的 indexOf() 函数，用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型 int。这个时候，我们就无法用 NULL 值来表示不存在的情况了。对于这种情况，我们有两种处理思路，一种是返回 NotFoundException，**一种是返回一个特殊值，比如 -1。不过，显然 -1 更加合理，理由也是同样的，也就是说“没有查找到”是一种正常而非异常的行为**。

**4. 抛出异常对象**

尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式是抛出异常。异常有两种类型：受检异常和非受检异常。

对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。

**对于函数抛出的异常，我们有三种处理方法：直接吞掉、直接往上抛出、包裹成新的异常抛出。**





### 44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？

一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。

重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？

抽象工厂模式的应用场景比较特殊，没有前两种常用。**抽象工厂可以让一个工厂负责创建多个不同类型的对象。这样就可以有效地减少工厂类的个数。**

在今天讲的三种工厂模式中，**简单工厂和工厂方法比较常用**，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景进行总结。

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用**工厂模式，封装对象的创建过程，将对象的创建和使用相分离**。何为创建逻辑比较复杂呢？我总结了下面两种情况。

- 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 ifelse 创建对象的代码抽离出来，放到工厂类中。
- 还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。

对于第一种情况，**当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中**。**当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。**同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。

除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。

现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准。

- **封装变化**：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- **代码复用**：创建代码抽离到独立的工厂类之后可以复用。
- **隔离复杂性**：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- **控制复杂度**：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。





### 45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？

#### 工厂模式和 DI 容器有何区别？

实际上，**DI 容器底层最基本的设计思路就是基于工厂模式的**。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。

DI 容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，**一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。**

除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。

#### DI 容器的核心功能有哪些？

总结一下，一个简单的 DI 容器的核心功能一般有三个：**配置解析**、**对象创建**和**对象生命周期管理**。





### 46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式

#### 为什么需要建造者模式？

为了解决一些问题，比如：

XXX 参数是必填的

除此之外，假设配置项之间有一定的依赖关系，配置项之间的依赖关系或者约束条件的校验逻辑。 a > b + c

希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。



我们可以把**校验逻辑放置到 Builder 类中**，**先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象**。除此之外，我们**把 ResourcePoolConfig 的构造函数改为 private 私有权限。**这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，**ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了**。



#### 与工厂模式有何区别？

实际上，**工厂模式是用来创建不同但是相关类型的对象**（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。**建造者模式是用来创建一种类型的复杂对象**，通过设置不同的可选参数，“定制化”地创建不同的对象。

**使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。**



#### 重点回顾

建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。

- 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果**必填的属性有很多**，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
- 如果**类的属性之间有一定的依赖关系或者约束条件**，我们继续使用构造函数配合 set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
- 如果我们**希望创建不可变对象**，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。

除此之外，在今天的讲解中，我们还对比了工厂模式和建造者模式的区别。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。 



### 47 | 原型模式：如何最快速地clone一个HashMap散列表？

对于创建型模式，前面我们已经讲了[单例模式](https://so.csdn.net/so/search?from=pc_blog_highlight&q=单例模式)、工厂模式、建造者模式，今天我们来讲最后一个：原型模式。

#### 原型模式的原理与应用

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作**原型设计模式（Prototype Design Pattern）**，简称**原型模式**。

#### 深拷贝和浅拷贝

浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200510055357677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FoYV9qYXNwZXI=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200510055435856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FoYV9qYXNwZXI=,size_16,color_FFFFFF,t_70)

在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。

#### 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

**1. 什么是原型模式？**

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以**利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式**。

**2. 原型模式的两种实现方法**

原型模式有两种实现方法，**深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。**所以，**深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。**

如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载 10万条数据并构建散列表索引，操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。







### 48 | 代理模式：代理在RPC、缓存、监控等场景中的应用

前面几节，我们学习了设计模式中的创建型模式。**创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。**

**其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。**

从今天起，我们开始学习另外一种类型的设计模式：结构型模式。**结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。**今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。





#### 代理模式的应用场景

代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。

**1. 业务系统的非功能性需求开发**

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们**将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发**。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。

如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。

**2. 代理模式在 RPC、缓存中的应用**

**实际上，RPC 框架也可以看作一种代理模式**，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。





#### 重点回顾

**1. 代理模式的原理与实现**

**在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能**。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

**2. 动态代理的原理与实现**

**静态代理需要针对每个类都创建一个代理类**，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

**3. 代理模式的应用场景**

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。



我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。

组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。
继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。



